(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{381:function(_,v,t){"use strict";t.r(v);var e=t(26),o=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_2-二分查找的问题变种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-二分查找的问题变种"}},[_._v("#")]),_._v(" 2. 二分查找的问题变种")]),_._v(" "),t("p",[_._v("事实上，「力扣」上的「二分查找」问题没有那么简单。例如，让我们找：")]),_._v(" "),t("ul",[t("li",[_._v("大于等于 "),t("code",[_._v("target")]),_._v(" 的下标最小的元素；")]),_._v(" "),t("li",[_._v("小于等于 "),t("code",[_._v("target")]),_._v(" 的下标最大的元素。")])]),_._v(" "),t("p",[_._v("这样的问题有一个特点："),t("strong",[_._v("当看到了 "),t("code",[_._v("nums[mid]")]),_._v(" 恰好等于 "),t("code",[_._v("target")]),_._v(" 的时候，还得继续查找")]),_._v("，继续看看左边的元素的值，或者继续看看右边元素的值。如果不小心，很可能逻辑写错。如果还用「1. 二分查找的基本问题」介绍的方式编写代码，就没有那么容易：")]),_._v(" "),t("ul",[t("li",[t("code",[_._v("while")]),_._v(" 里面的 "),t("code",[_._v("if")]),_._v(" 、"),t("code",[_._v("else")]),_._v(" 该怎么写，有没有什么固定的思路？")]),_._v(" "),t("li",[_._v("退出循环以后，"),t("code",[_._v("right")]),_._v(" 在左，"),t("code",[_._v("left")]),_._v(" 在右，返回 "),t("code",[_._v("left")]),_._v(" 还是 "),t("code",[_._v("right")]),_._v(" 需要分类讨论。")])]),_._v(" "),t("p",[_._v("本题解要介绍的「二分查找」的思想其实不是什么新鲜的事儿。如下图所示，它像极了「双指针」算法，"),t("code",[_._v("left")]),_._v(" 和 "),t("code",[_._v("right")]),_._v(" 向中间走，直到它们重合在一起。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://pic.leetcode-cn.com/1617955110-eWCqKj-image.png",alt:"image.png"}})]),_._v(" "),t("p",[_._v("这种二分查找的思考路径，不是我发明的（「参考资料」在题解最后）。我一开始看到这种写法也觉得很惊讶，也搞不明白到底怎么回事，但是我看到的解释就只有「这是模板」，但没有看到为什么有这个模板。因此我 "),t("strong",[_._v("尝试去了解它，并使用它")]),_._v("，然后整理成这篇题解。用这种二分查找的思路，可以解决「力扣」上 "),t("strong",[_._v("所有的")]),_._v(" 「二分查找」问题。")])])}),[],!1,null,null,null);v.default=o.exports}}]);