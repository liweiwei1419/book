(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{384:function(t,v,_){"use strict";_.r(v);var e=_(26),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_3-把待搜索区间分成两个部分-重点、最重要的部分在这里"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-把待搜索区间分成两个部分-重点、最重要的部分在这里"}},[t._v("#")]),t._v(" 3. 把待搜索区间分成两个部分（重点、最重要的部分在这里）")]),t._v(" "),_("p",[t._v("根据看到的中间位置的元素的值 "),_("code",[t._v("nums[mid]")]),t._v(" 可以把待搜索区间分为两个部分：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("一定不存在")]),t._v(" 目标元素的区间：下一轮搜索的时候，不用考虑它；")]),t._v(" "),_("li",[_("strong",[t._v("可能存在")]),t._v(" 目标元素的区间：下一轮搜索的时候，需要考虑它。")])]),t._v(" "),_("p",[t._v("由于 "),_("code",[t._v("mid")]),t._v(" 只可能被分到这两个区间的其中一个，即："),_("code",[t._v("while")]),t._v(" 里面的 "),_("code",[t._v("if")]),t._v(" 和 "),_("code",[t._v("else")]),t._v(" 就两种写法：")]),t._v(" "),_("ul",[_("li",[t._v("如果 "),_("code",[t._v("mid")]),t._v(" 分到左边区间，即区间分成 "),_("code",[t._v("[left..mid]")]),t._v(" 与 "),_("code",[t._v("[mid + 1..right]")]),t._v("，此时分别设置 "),_("code",[t._v("right = mid")]),t._v(" 与 "),_("code",[t._v("left = mid + 1")]),t._v("；")]),t._v(" "),_("li",[t._v("如果 "),_("code",[t._v("mid")]),t._v(" 分到右边区间，即区间分成 "),_("code",[t._v("[left..mid - 1]")]),t._v(" 与 "),_("code",[t._v("[mid..right]")]),t._v("，此时分别设置 "),_("code",[t._v("right = mid - 1")]),t._v(" 与 "),_("code",[t._v("left = mid")]),t._v("。")])]),t._v(" "),_("p",[t._v("并且把 "),_("strong",[t._v("循环可以继续的条件")]),t._v(" 写成 "),_("code",[t._v("while (left < right)")]),t._v("。"),_("strong",[t._v("在上面把待搜索区间分成两个部分的情况下，退出循环以后一定会有 "),_("code",[t._v("left == right")]),t._v(" 成立")]),t._v("，因此在退出循环以后，不需要考虑到底返回 "),_("code",[t._v("left")]),t._v(" 还是返回 "),_("code",[t._v("right")]),t._v("。")]),t._v(" "),_("p",[t._v("这里介绍一个 「"),_("strong",[t._v("重要的经验")]),t._v("」：")]),t._v(" "),_("blockquote",[_("p",[t._v("在 "),_("strong",[t._v("写 "),_("code",[t._v("if")]),t._v(" 语句的时候，通常把容易想到的，不容易出错的逻辑写在 "),_("code",[t._v("if")]),t._v(" 的里面")]),t._v("，这样就把复杂的、容易出错的情况放在了 "),_("code",[t._v("else")]),t._v(" 的部分，这样编写代码不容易出错。")])]),t._v(" "),_("p",[t._v("什么情况是容易想到的，不容易出错的呢？我的经验是：题目要我们找符合条件 a 的元素，我们就对条件 a 取反面，这样分析不容易出错。")]),t._v(" "),_("p",[t._v("例如本题（「力扣」第 35 题），题目要我们找出第一个大于等于 "),_("code",[t._v("target")]),t._v(" 的元素的下标，那么小于 "),_("code",[t._v("target")]),t._v(" 的元素就一定不是我们要找的。因此 "),_("code",[t._v("if")]),t._v(" 语句就是")]),t._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nums"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mid"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" target"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下一轮搜索区间是 [mid + 1..right]")]),t._v("\n\tleft "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mid "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br")])]),_("p",[t._v("剩下的情况放在 "),_("code",[t._v("else")]),t._v(" 中，我们 "),_("strong",[t._v("甚至可以不用分析 "),_("code",[t._v("else")]),t._v(" 是什么情况")]),t._v("。"),_("code",[t._v("if")]),t._v(" 的区间是 "),_("code",[t._v("[mid + 1..right]")]),t._v("，它的反面区间就是 "),_("code",[t._v("[left..mid]")]),t._v("，此时 "),_("code",[t._v("else")]),t._v(" 就应该设置 "),_("code",[t._v("right = mid")]),t._v("。")]),t._v(" "),_("p",[t._v("因此完整的逻辑就是：")]),t._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nums"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("mid"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" target"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下一轮搜索区间是 [mid + 1..right]")]),t._v("\n\tleft "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mid "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tright "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mid"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br")])]),_("p",[t._v("上面的叙述，总结起来就一句话：我们 "),_("strong",[t._v("总是在区间 "),_("code",[t._v("[left..right]")]),t._v(" 里查找元素目标")]),t._v("。")]),t._v(" "),_("p",[_("strong",[t._v("注意")]),t._v("：我们说的是 "),_("strong",[t._v("左闭右闭区间")]),t._v("。为什么不是「左闭右开」呢？「左闭右开」当然可以，但是我们 "),_("strong",[t._v("不想把精力花在思考「右边界是不是可以取到」这件事情上")]),t._v("，这是因为 "),_("strong",[t._v("任意一个「左闭右开 "),_("code",[t._v("[left..right)")]),t._v(" 」区间一定唯一对应一个「左闭右闭 "),_("code",[t._v("[left..right - 1]")]),t._v("」区间")]),t._v("，所以到底是开区间还是闭区间，前后保持一致就可以。")]),t._v(" "),_("p",[t._v("根据 "),_("code",[t._v("mid")]),t._v(" 位置是不是目标元素，进而判断 "),_("code",[t._v("mid")]),t._v(" 的左边是否存在目标元素，"),_("code",[t._v("mid")]),t._v(" 的右边是否存在目标元素，只把搜索区间分为两个部分，然后设置 "),_("code",[t._v("left")]),t._v(" 和 "),_("code",[t._v("right")]),t._v("，"),_("strong",[t._v("在设置 "),_("code",[t._v("left")]),t._v(" 和 "),_("code",[t._v("right")]),t._v(" 的时候，左闭右闭区间的形式是最直观的，这是因为如果是开区间，还需要在脑子里反应一下，右端点不包括")]),t._v("。如果我们觉得二分问题复杂，复杂问题应该简单做。")]),t._v(" "),_("p",[t._v("我们再说说把区间分成两个部分的好处：")]),t._v(" "),_("p",[t._v("在代码层面，只可能有以下两种情况：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("while(left < right)")]),t._v(" 与 "),_("code",[t._v("left = mid + 1")]),t._v(" 、 "),_("code",[t._v("right = mid")]),t._v(" 的搭配；")]),t._v(" "),_("li",[_("code",[t._v("while(left < right)")]),t._v(" 与 "),_("code",[t._v("left = mid")]),t._v(" 、 "),_("code",[t._v("right = mid - 1")]),t._v(" 的搭配；")])]),t._v(" "),_("p",[_("strong",[t._v("只有在这两种把区间分成两个部分的划分下，退出循环以后有 "),_("code",[t._v("left == right")]),t._v(" 成立，我们不用去讨论返回 "),_("code",[t._v("left")]),t._v(" 还是 "),_("code",[t._v("right")]),t._v("（这句话非常重要，大家可以在做题的过程中慢慢体会）")]),t._v("。")]),t._v(" "),_("blockquote",[_("p",[t._v("补充说明：有的朋友觉得把区间分为三个部分更清晰，但是一旦分成三个部分，有 "),_("code",[t._v("mid + 1")]),t._v("、"),_("code",[t._v("mid - 1")]),t._v(" 出现，退出循环以后就不一定有 "),_("code",[t._v("left")]),t._v(" 和 "),_("code",[t._v("right")]),t._v(" 重合。我们完全可以这样做，分类讨论的时候分成三个部分，然后把它们的逻辑合并起来。")])]),t._v(" "),_("p",[t._v("在我们的讲解中 "),_("code",[t._v("while(left < right)")]),t._v(" 与「定义的区间是 "),_("code",[t._v("[left..right)")]),t._v(" 」没有任何关系，请大家不要做多余的解读，我们不讲循环不变量是 "),_("code",[t._v("[left..right)")]),t._v(" 的情况，我们只认为区间是「左闭右闭」区间，理由上面也说了，每一个位置的值是不是可以取到，我们需要非常清楚，而不想看到一个开区间，我们在脑子里需要想一下「右端点不包括」。")]),t._v(" "),_("p",[_("strong",[t._v("至于为什么是 "),_("code",[t._v("left = mid + 1")]),t._v(" 、 "),_("code",[t._v("right = mid")]),t._v(" 搭配使用，而 "),_("code",[t._v("left = mid")]),t._v(" 、 "),_("code",[t._v("right = mid - 1")]),t._v(" 搭配使用，这一点完全不用记忆")]),t._v("，我们画图说明。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://pic.leetcode-cn.com/1617857363-gTiArD-image.png",alt:"image.png"}}),t._v('{:style="width:500px"}')]),t._v(" "),_("p",[t._v("因此我们再次和大家强调：永远去思考下一轮搜索应该在哪个区间里，就能考虑清楚到底下一轮更新的是 "),_("code",[t._v("left")]),t._v(" 还是 "),_("code",[t._v("right")]),t._v(" ，到底加不加 "),_("code",[t._v("1")]),t._v("，到底减不减 "),_("code",[t._v("1")]),t._v("。")])])}),[],!1,null,null,null);v.default=s.exports}}]);