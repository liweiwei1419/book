(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{390:function(t,a,r){"use strict";r.r(a);var s=r(26),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("我们在为大家总结一下递推与递归的区别，递推是从一个问题最开始的样子一直推倒，直到我们解决了这个问题，Er递归呢，是一种自顶向下的思想，我们直接面对要解决的问题，将它进行拆分以后足成的向下进行拆分，直到我们解决了那个不能够继续拆分的问题以后，一层一层地向上返回，直到我们解决了这个问题，因此递归在解决问题的过程当中会实现较多的函数调用，也会占用一定的开销，但是递归可以帮助我们将问题简化，这是因为我们很多时候。")]),t._v(" "),r("p",[t._v("这是因为很多时候我们不能够很方便地看出原问题与子问题的关系，我们利用递归调用完成以后的合并的操作，可以实现一些简单的逻辑，在下一节，我们通过处理链表以及树形结构当中的问题来理解递归函数的调用过程。")]),t._v(" "),r("h2",{attrs:{id:"深度优先遍历-回溯算法-中的递归语义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先遍历-回溯算法-中的递归语义"}},[t._v("#")]),t._v(" 深度优先遍历（回溯算法）中的递归语义")]),t._v(" "),r("p",[t._v("我们知道：支持「深度优先遍历」实现的数据结构是「栈」，而支持「广度优先遍历」实现的数据结构是「队列」。")]),t._v(" "),r("p",[t._v("「力扣」第 79 题")]),t._v(" "),r("h2",{attrs:{id:"编写递归函数代替栈的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编写递归函数代替栈的实现"}},[t._v("#")]),t._v(" 编写递归函数代替栈的实现")]),t._v(" "),r("p",[t._v("「并查集」中的路径压缩。")])])}),[],!1,null,null,null);a.default=e.exports}}]);