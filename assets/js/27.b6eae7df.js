(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{391:function(t,s,r){"use strict";r.r(s);var a=r(26),c=Object(a.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"第-1-节-分而治之的算法设计思想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第-1-节-分而治之的算法设计思想"}},[t._v("#")]),t._v(" 第 1 节 分而治之的算法设计思想")]),t._v(" "),r("h2",{attrs:{id:"递归与分治"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#递归与分治"}},[t._v("#")]),t._v(" 递归与分治")]),t._v(" "),r("ul",[r("li",[t._v("递归是编程技巧，"),r("strong",[t._v("直接体现在代码上")]),t._v(" ，即 "),r("strong",[t._v("函数自己调用自己")]),t._v("，每一层递归调用，传入的参数的值并不完全一样；")]),t._v(" "),r("li",[t._v("分治是一种算法设计的思想，绝大部分情况下「分治算法」通过「递归」实现。即：子问题的求解通过递归方法实现。")])]),t._v(" "),r("p",[t._v("算法和数据结构并不是凭空想象出来的，「递归」函数也不例外。「递归」函数基于 "),r("strong",[t._v("「自顶向下」拆分问题，再「自底向上」逐层解决问题的思想")]),t._v(" 设计而成，这是所熟知的「分而治之」的算法思想。")]),t._v(" "),r("h2",{attrs:{id:"递归函数的设计思想-分而治之-减而治之"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#递归函数的设计思想-分而治之-减而治之"}},[t._v("#")]),t._v(" 递归函数的设计思想：分而治之（减而治之）")]),t._v(" "),r("p",[t._v("分而治之（Divide-and-Conquer）的思想分为如下三步：")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("拆分")]),t._v("：将原问题拆分成若干个子问题；")]),t._v(" "),r("li",[r("strong",[t._v("解决")]),t._v("：解决这些子问题；")]),t._v(" "),r("li",[r("strong",[t._v("合并")]),t._v("：合并子问题的解得到原问题的解。")])]),t._v(" "),r("p",[r("strong",[t._v("注意")]),t._v("：第 2 步「解决这些子问题」不是逐个解决。是以一种「深度优先」或者说「递归」的方式解决某个子问题，等到该子问题解决完成以后，在解决同一层的其它子问题。大家可以结合我们后面给出的例子进行理解。")]),t._v(" "),r("p",[t._v("典型的分治思想的应用是：归并排序、快速排序、绝大多数「树」中的问题（先把原问题拆分成子树的问题，当子树中的问题解决以后，结合子树求解的结果处理当前结点）、链表中的问题。")]),t._v(" "),r("p",[t._v("我们在本教程里不对「分治思想」展开叙述。")]),t._v(" "),r("p",[t._v("「分治思想」的特例是「减治思想（Decrease-and-Conquer）」：每一步将问题转换成为规模更小的子问题。「减治思想」思想的典型应用是「二分查找」「选择排序」「插入排序」「快速排序」算法。「分治」与「减治思想」的区别如下：")]),t._v(" "),r("ul",[r("li",[t._v("分治思想：将一个问题拆分成若干个子问题，然后再逐个求解，根据各个子问题得到的结果得到原问题的结果；")]),t._v(" "),r("li",[t._v("减治思想：在拆分子问题的时候，只将原问题转化成 "),r("strong",[t._v("一个")]),t._v(" 规模更小的子问题，因此子问题的结果就是上一层原问题的结果，每一步只需要解决一个规模更小的子问题，相比较于「分治思想」而言，它 "),r("strong",[t._v("没有「合并」的过程")]),t._v("。")])]),t._v(" "),r("hr"),t._v(" "),r("h2",{attrs:{id:"自顶向下地解决问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自顶向下地解决问题"}},[t._v("#")]),t._v(" 自顶向下地解决问题")]),t._v(" "),r("p",[t._v("使用「递归」的思想解决问题的方案是：从「结果」推向「源头」，再从「源头」返回「结果」。我们以计算 "),r("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[r("mjx-math",{staticClass:" MJX-TEX"},[r("mjx-mn",{staticClass:"mjx-n"},[r("mjx-c",{attrs:{c:"5"}})],1),r("mjx-mo",{staticClass:"mjx-n"},[r("mjx-c",{attrs:{c:"!"}})],1)],1)],1),t._v(" 为例向大家解释什么是「自顶向下」地解决问题。")],1),t._v(" "),r("p",[t._v("下面的幻灯片演示了使用「递归」方法「自顶向下」地计算 "),r("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[r("mjx-math",{staticClass:" MJX-TEX"},[r("mjx-mn",{staticClass:"mjx-n"},[r("mjx-c",{attrs:{c:"5"}})],1),r("mjx-mo",{staticClass:"mjx-n"},[r("mjx-c",{attrs:{c:"!"}})],1)],1)],1),t._v(" 的步骤。编程语言在执行计算的过程中，使用了数据结构「栈」。")],1),t._v(" "),r("p",[t._v("<"),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-PLiIto-recursion.001.jpeg",alt:"recursion.001.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-pxxYsj-recursion.002.jpeg",alt:"recursion.002.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-wRLHqR-recursion.003.jpeg",alt:"recursion.003.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-qLQgWz-recursion.004.jpeg",alt:"recursion.004.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-zkKIUh-recursion.005.jpeg",alt:"recursion.005.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-qbqYUq-recursion.006.jpeg",alt:"recursion.006.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-wrCbIX-recursion.007.jpeg",alt:"recursion.007.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-ZEoXtQ-recursion.008.jpeg",alt:"recursion.008.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-KLUAzN-recursion.009.jpeg",alt:"recursion.009.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-BSTCQZ-recursion.010.jpeg",alt:"recursion.010.jpeg"}}),t._v(","),r("img",{attrs:{src:"https://pic.leetcode-cn.com/1616382148-mmqxwT-recursion.011.jpeg",alt:"recursion.011.jpeg"}}),t._v(">")]),t._v(" "),r("hr"),t._v(" "),r("h2",{attrs:{id:"为什么需要使用栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要使用栈"}},[t._v("#")]),t._v(" 为什么需要使用栈？")]),t._v(" "),r("p",[t._v("在计算 "),r("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[r("mjx-math",{staticClass:" MJX-TEX"},[r("mjx-mn",{staticClass:"mjx-n"},[r("mjx-c",{attrs:{c:"5"}})],1),r("mjx-mo",{staticClass:"mjx-n"},[r("mjx-c",{attrs:{c:"!"}})],1)],1)],1),t._v(" 的过程当中，需要记录拆分的过程当中的每一个子问题，并且在求解每一个子问题以后，逐层向上汇报结果。"),r("strong",[t._v("后拆分的子问题先得到了解决，整个过程恰好符合「后进先出」的规律")]),t._v(" ，因此需要借助的数据结构是「栈」。")],1),t._v(" "),r("h2",{attrs:{id:"拆分的时候「先走出去」-合并的时候「再走回来」"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拆分的时候「先走出去」-合并的时候「再走回来」"}},[t._v("#")]),t._v(" 拆分的时候「先走出去」，合并的时候「再走回来」")]),t._v(" "),r("p",[t._v("使用「递归」实现的算法需要走完下面两条路径：")]),t._v(" "),r("ul",[r("li",[t._v("先「自顶向下」拆分问题，直到不能拆分为止；")]),t._v(" "),r("li",[t._v("再「自底向上」逐层把底层的结果向上汇报，直至得到原问题的解。")])]),t._v(" "),r("p",[t._v("因此使用「递归」函数解决的问题如上图所示，有「"),r("strong",[t._v("先走出去，再走回来")]),t._v("」的过程。")]),t._v(" "),r("h2",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),r("ul",[r("li",[t._v("「分治」是思想，「减治」是分治的特例；")]),t._v(" "),r("li",[t._v("「递归」是代码表现形式；")]),t._v(" "),r("li",[t._v("「递归」有先拆分问题的过程，真正解决问题，需要在拆分到底以后，一层一层向上返回。")])])])}),[],!1,null,null,null);s.default=c.exports}}]);