<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《统计学习方法》第 9 章“EM 算法及其推广”学习笔记 | 算法不好玩</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/book/logo.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="">
    
    <link rel="preload" href="/book/assets/css/0.styles.e159a327.css" as="style"><link rel="preload" href="/book/assets/js/app.a4355b0d.js" as="script"><link rel="preload" href="/book/assets/js/2.ba785ee6.js" as="script"><link rel="preload" href="/book/assets/js/41.f7b72b7a.js" as="script"><link rel="prefetch" href="/book/assets/js/10.b6950be1.js"><link rel="prefetch" href="/book/assets/js/11.f4ee7d6e.js"><link rel="prefetch" href="/book/assets/js/12.50fe1ace.js"><link rel="prefetch" href="/book/assets/js/13.42356fcc.js"><link rel="prefetch" href="/book/assets/js/14.e740c742.js"><link rel="prefetch" href="/book/assets/js/15.05c628f7.js"><link rel="prefetch" href="/book/assets/js/16.bd9bc9d5.js"><link rel="prefetch" href="/book/assets/js/17.e120b4fc.js"><link rel="prefetch" href="/book/assets/js/18.398213f8.js"><link rel="prefetch" href="/book/assets/js/19.e29ad0b2.js"><link rel="prefetch" href="/book/assets/js/20.14e30c1c.js"><link rel="prefetch" href="/book/assets/js/21.4f05f6c9.js"><link rel="prefetch" href="/book/assets/js/22.98fbf199.js"><link rel="prefetch" href="/book/assets/js/23.285387f4.js"><link rel="prefetch" href="/book/assets/js/24.852addbe.js"><link rel="prefetch" href="/book/assets/js/25.d30ade13.js"><link rel="prefetch" href="/book/assets/js/26.23dfa040.js"><link rel="prefetch" href="/book/assets/js/27.b6eae7df.js"><link rel="prefetch" href="/book/assets/js/28.97878b08.js"><link rel="prefetch" href="/book/assets/js/29.7217a3d0.js"><link rel="prefetch" href="/book/assets/js/3.f0c15194.js"><link rel="prefetch" href="/book/assets/js/30.0ced5a5a.js"><link rel="prefetch" href="/book/assets/js/31.8f432033.js"><link rel="prefetch" href="/book/assets/js/32.aac9aa62.js"><link rel="prefetch" href="/book/assets/js/33.db835477.js"><link rel="prefetch" href="/book/assets/js/34.a1a59c2a.js"><link rel="prefetch" href="/book/assets/js/35.ed2ef96b.js"><link rel="prefetch" href="/book/assets/js/36.48099c55.js"><link rel="prefetch" href="/book/assets/js/37.32827612.js"><link rel="prefetch" href="/book/assets/js/38.58abec0e.js"><link rel="prefetch" href="/book/assets/js/39.f6eb3874.js"><link rel="prefetch" href="/book/assets/js/4.13ea3b32.js"><link rel="prefetch" href="/book/assets/js/40.80523ed8.js"><link rel="prefetch" href="/book/assets/js/42.44e40de9.js"><link rel="prefetch" href="/book/assets/js/43.065f077f.js"><link rel="prefetch" href="/book/assets/js/44.386d9aea.js"><link rel="prefetch" href="/book/assets/js/45.d8a88f16.js"><link rel="prefetch" href="/book/assets/js/46.33bc2083.js"><link rel="prefetch" href="/book/assets/js/47.e7767237.js"><link rel="prefetch" href="/book/assets/js/48.9bb76138.js"><link rel="prefetch" href="/book/assets/js/49.c2ca5c29.js"><link rel="prefetch" href="/book/assets/js/5.32eda204.js"><link rel="prefetch" href="/book/assets/js/50.1242fe24.js"><link rel="prefetch" href="/book/assets/js/51.e8f8117d.js"><link rel="prefetch" href="/book/assets/js/52.eae5648f.js"><link rel="prefetch" href="/book/assets/js/53.39876d83.js"><link rel="prefetch" href="/book/assets/js/6.1c662163.js"><link rel="prefetch" href="/book/assets/js/7.29470445.js"><link rel="prefetch" href="/book/assets/js/8.814b737f.js"><link rel="prefetch" href="/book/assets/js/9.d4211262.js">
    <link rel="stylesheet" href="/book/assets/css/0.styles.e159a327.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book/" class="home-link router-link-active"><!----> <span class="site-name">算法不好玩</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/book/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/book/guide/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础算法与数据结构" class="dropdown-title"><span class="title">基础算法与数据结构</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础算法与数据结构" class="mobile-dropdown-title"><span class="title">基础算法与数据结构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          排序算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/book/algs/01-binary-search/" class="nav-link">
  第 1 章 二分查找
</a></li><li class="dropdown-subitem"><a href="/book/algs/recursion/" class="nav-link">
  第 2 章 递归
</a></li></ul></li><li class="dropdown-item"><h4>
          数组里的算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/book/algs/01-binary-search/" class="nav-link">
  第 4 章 滑动窗口
</a></li><li class="dropdown-subitem"><a href="/book/algs/02-basic-sorting/" class="nav-link">
  第 5 章 双指针
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="威威道来" class="dropdown-title"><span class="title">威威道来</span> <span class="arrow down"></span></button> <button type="button" aria-label="威威道来" class="mobile-dropdown-title"><span class="title">威威道来</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/book/talk-show/2021-04/" class="nav-link">
  2021 年 4 月
</a></li></ul></div></div><div class="nav-item"><a href="https://leetcode-cn.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  力扣
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/liweiwei1419/book/pages" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee 部署页面
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/book/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/book/guide/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础算法与数据结构" class="dropdown-title"><span class="title">基础算法与数据结构</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础算法与数据结构" class="mobile-dropdown-title"><span class="title">基础算法与数据结构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          排序算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/book/algs/01-binary-search/" class="nav-link">
  第 1 章 二分查找
</a></li><li class="dropdown-subitem"><a href="/book/algs/recursion/" class="nav-link">
  第 2 章 递归
</a></li></ul></li><li class="dropdown-item"><h4>
          数组里的算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/book/algs/01-binary-search/" class="nav-link">
  第 4 章 滑动窗口
</a></li><li class="dropdown-subitem"><a href="/book/algs/02-basic-sorting/" class="nav-link">
  第 5 章 双指针
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="威威道来" class="dropdown-title"><span class="title">威威道来</span> <span class="arrow down"></span></button> <button type="button" aria-label="威威道来" class="mobile-dropdown-title"><span class="title">威威道来</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/book/talk-show/2021-04/" class="nav-link">
  2021 年 4 月
</a></li></ul></div></div><div class="nav-item"><a href="https://leetcode-cn.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  力扣
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://gitee.com/liweiwei1419/book/pages" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee 部署页面
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>本文介绍了 EM 算法。</p></div> <p>EM 算法，即期望最大化（Expectation-Maximum）算法，用于含有隐变量的概率模型参数的极大似然估计。区别于微积分中通过求导得到最优解的方法，EM 算法是一种迭代算法，并不保证能够得到全局最优解，但可以得到一个局部最优解。</p> <p>我们所熟知的 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法其实是 EM 算法的一个特例。</p> <h3 id="em-算法的基本思想"><a href="#em-算法的基本思想" class="header-anchor">#</a> EM 算法的基本思想</h3> <p>EM 算法的思想是<strong>先固定其中一个，推测另一个，如此反复</strong>。</p> <p>例如：模型中有两个未知参数 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="A"></mjx-c></mjx-mi></mjx-math></mjx-container> 和 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="B"></mjx-c></mjx-mi></mjx-math></mjx-container> 需要估计，而 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="A"></mjx-c></mjx-mi></mjx-math></mjx-container> 和 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="B"></mjx-c></mjx-mi></mjx-math></mjx-container> 又存在相互依赖的关系，即知道 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="A"></mjx-c></mjx-mi></mjx-math></mjx-container> 才能推出 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="B"></mjx-c></mjx-mi></mjx-math></mjx-container>，知道了 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="B"></mjx-c></mjx-mi></mjx-math></mjx-container> 才能推出 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="A"></mjx-c></mjx-mi></mjx-math></mjx-container> ，这样的问题就可以用 EM 算法。</p> <p>使用极大似然估计，通过迭代算法，既能估计模型的参数，并且还能得到隐变量的值。注意：EM 算法<strong>并不保证得到全局最优解，但是可以得到局部最优解，这一点和梯度下降法是一样的，最终的解和初值有关</strong>，这一点在 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法中是一样的。</p> <h3 id="em-算法用于解决含有隐含变量的概率模型的参数估计问题"><a href="#em-算法用于解决含有隐含变量的概率模型的参数估计问题" class="header-anchor">#</a> EM 算法用于解决含有隐含变量的概率模型的参数估计问题</h3> <p>EM 算法是对概率模型进行参数估计是一种常见的问题分析的方法。当然概率模型仅存在观测数据的时候，可以直接利用最大似然估计的方法，对似然函数取对数，令各个参数的偏导数为 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mn class="mjx-n"><mjx-c c="0"></mjx-c></mjx-mn></mjx-math></mjx-container>，求得的参数的值作为参数的估计。</p> <p>但是如果模型含有隐变量，并且隐函数和模型参数是互相影响的，就可以通过使用 EM 算法，通过迭代地求解隐含变量的充分统计量和最大化似然函数以达到参数估计的算法。这样即求得了隐变量，还得到了问题的参数估计。</p> <p>EM 算法刚接触的时候感觉很晦涩，不过如果熟悉了<mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法，往 EM 算法上靠就会发现， <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法其实就是在执行 EM 算法这个框架。先学习 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类，再来看 EM 算法，或许入门会简单一些。</p> <h3 id="通过-均值聚类算法学习-em-算法"><a href="#通过-均值聚类算法学习-em-算法" class="header-anchor">#</a> 通过 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法学习 EM 算法</h3> <p>这里“同类数据点到其中心的距离之和最短”就等价于似然函数最大。</p> <p>学习 EM 算法的时候，很容易把自己绕晕，陷入“鸡生蛋、蛋生鸡”的循环，不过可以通过 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类理解 EM 算法的 E 步和 M 步。在 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类中，首先要明确“模型参数”和“隐变量”分别是什么？</p> <p>1、每个聚类簇的质心是“隐变量”，“隐变量”决定了一个数据属于哪一个类别，一个数据属于距离它最近的质心所所属的类别。</p> <p>2、我们要求的是哪些数据可以归为一类，这我们可以理解为是“模型的参数”，是我们直接要求的；</p> <p>接下来，我们对比  <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法和 EM 算法：</p> <table><thead><tr><th><mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法</th> <th>EM 算法</th> <th>说明</th></tr></thead> <tbody><tr><td></td> <td>（1）选择参数的初值，开始迭代；</td> <td></td></tr> <tr><td>（1）首先选择 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 个类别的中心；（3）然后更新每个样本的均值，作为类的新的中心。</td> <td>（2）E 步：记 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-msup><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-script style="vertical-align:0.363em;"><mjx-TeXAtom size="s"><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-TeXAtom></mjx-script></mjx-msup></mjx-math></mjx-container> 为第 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi></mjx-math></mjx-container> 次迭代参数 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi></mjx-math></mjx-container> 的估计值，在第 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi><mjx-mo space="3" class="mjx-n"><mjx-c c="+"></mjx-c></mjx-mo><mjx-mn space="3" class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn></mjx-math></mjx-container> 次迭代的 E 步，计算 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="Q"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msup space="2"><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-script style="vertical-align:0.363em;"><mjx-TeXAtom size="s"><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-TeXAtom></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-math></mjx-container>；</td> <td>求出隐变量</td></tr> <tr><td>（2）将样本逐个指派到与其最近的中心的类中，得到一个聚类的结果。</td> <td>（3）M 步：求使 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="Q"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msup space="2"><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-script style="vertical-align:0.363em;"><mjx-TeXAtom size="s"><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-TeXAtom></mjx-script></mjx-msup><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-math></mjx-container> 极大化的 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi></mjx-math></mjx-container>，确定第 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi><mjx-mo space="3" class="mjx-n"><mjx-c c="+"></mjx-c></mjx-mo><mjx-mn space="3" class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn></mjx-math></mjx-container> 次迭代的参数的估计值 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-msup><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-script style="vertical-align:0.363em;"><mjx-TeXAtom size="s"><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="i"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c="+"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-TeXAtom></mjx-script></mjx-msup></mjx-math></mjx-container>；</td> <td>求出模型参数</td></tr> <tr><td>重复第（3）步和第（2）步，直到收敛为止。</td> <td>（4）重复第（2）步和第（3）步，直到收敛。</td> <td></td></tr> <tr><td>李航《统计学习方法》（第 2 版）P264</td> <td>李航《统计学习方法》（第 2 版）P178</td> <td></td></tr></tbody></table> <p>我又画了一个表格，可能这样看会更清楚一些：</p> <table><thead><tr><th><mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类 聚类算法</th> <th>EM 算法</th></tr></thead> <tbody><tr><td>第 1 步：随机初始化给出质心，这一步可以认为是求出了隐变量。</td> <td>E 步：固定模型参数，求隐含变量。</td></tr> <tr><td>第 2 步：固定质心，把每个数据分配给最近的质心，这一步可以认为是求出模型参数。</td> <td>M 步：固定隐含变量，求模型参数。</td></tr> <tr><td>第 3 步：把是同类数据点取平均，更新质心，这一步可以认为是求出了隐变量。</td> <td>E 步：固定模型参数，求隐含变量。</td></tr> <tr><td>第 4 步：固定质心，把每个数据分配给最近的质心，这一步可以认为是求出模型参数。</td> <td>M 步：固定隐含变量，求模型参数。</td></tr> <tr><td>重复第 3 步、第 4 步，直到质心不再变化或者满足最大迭代次数位置。</td> <td>重复 E 步和 M 步。</td></tr></tbody></table> <p>这里再强调一下：<mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="k"></mjx-c></mjx-mi></mjx-math></mjx-container> 均值聚类算法的隐变量是质心，模型的参数是每个数据点属于哪个分类。再看看 EM 算法的 E 步和 M 步：</p> <ul><li>E  步（固定模型参数，求隐变量）</li></ul> <p>同类数据点取平均，其实就是在每一个数据点确定的情况下，求隐变量质心的概率分布。具体说来，即我们已知一些数据点的集合 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="S"></mjx-c></mjx-mi></mjx-math></mjx-container>，我们想求得一个点 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="o"></mjx-c></mjx-mi></mjx-math></mjx-container>，使得这个点 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="o"></mjx-c></mjx-mi></mjx-math></mjx-container> 与所有集合 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="S"></mjx-c></mjx-mi></mjx-math></mjx-container> 中的点的距离之和最小，我们很容易知道，这个点 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="o"></mjx-c></mjx-mi></mjx-math></mjx-container> 就应该取成集合 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="S"></mjx-c></mjx-mi></mjx-math></mjx-container> 中所有的点的各个分类的平均值（用距离之和对每个分量求偏导，并令偏导数为 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mn class="mjx-n"><mjx-c c="0"></mjx-c></mjx-mn></mjx-math></mjx-container>）</p> <p>根据参数初始值或上一次迭代的模型参数来计算出隐性变量的后验概率，其实就是隐变量的期望，作为隐藏变量的现估计值。即在当前估计的参数 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="3B8"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c c="t"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo></mjx-math></mjx-container> 的情况下给定 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="X"></mjx-c></mjx-mi></mjx-math></mjx-container>，计算对数似然函数在条件分布 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="Z"></mjx-c></mjx-mi></mjx-math></mjx-container> 下的期望值，即</p> <p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo>(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo>(</mo><mi>t</mi><mo>)</mo><mo>)</mo><mo>=</mo><msub><mi>E</mi><mrow><mi>Z</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo separator="true">,</mo><mi>θ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msub><mo>[</mo><mi>log</mi><mi>L</mi><mo>(</mo><mi>θ</mi><mo separator="true">;</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">Q(\theta|\theta(t))=E_{Z|X,\theta(t)}[\log L(\theta;X,Z)]
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">Q</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.18019999999999992em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="mpunct">;</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p> <ul><li>M 步（固定隐变量，求模型参数）</li></ul> <p>固定隐变量的前提下，求经过隐变量改写的似然函数的极大。质心确定的前提下，每个数据点分给最近的质心就能够使同类数据点到其中心的距离之和最短。找出使上式最大化的参数：</p>
\theta(t+1) = {\rm argmax}_{\theta}Q(\theta|\theta(t))

<p>示例代码：</p> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>mixture <span class="token keyword">import</span> GaussianMixture
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参数有：1、高斯混合模型的个数；2、协方差的类型；3、最大迭代次数。</p> <h3 id="理解-em-算法的迭代步骤"><a href="#理解-em-算法的迭代步骤" class="header-anchor">#</a> 理解 EM 算法的迭代步骤</h3> <p><img src="http://upload-images.jianshu.io/upload_images/414598-92dac0a5f654d2b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" EM 算法的迭代步骤"></p> <p>首先先找到“紫”线的一个下界函数，即“蓝”线，一定要有重合的那一个“点”，即被图中“绿”线确定的那个点。</p> <p>然后对“蓝”线取极大值，即被图中“红”线确定的那个点。</p> <p>如此反复，你会看到，只会逐步来到局部最优值点。</p> <h3 id="公式推导"><a href="#公式推导" class="header-anchor">#</a> 公式推导</h3> <p>手写笔记，我写在这里了：<a href="https://www.jianshu.com/p/e57838214b2b" target="_blank" rel="noopener noreferrer">EM 算法手写笔记<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>在公式推导的过程中，要用到 Jensen 不等式或者 KL 散度，也称相对熵。关于 Jensen 不等式，我写在这里了：<a href="https://www.liwei.party/2019/02/18/machine-learning/jenson/" target="_blank" rel="noopener noreferrer">Jenson 不等式的笔记<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。关于 KL 散度，我写在这里了：<a href="https://www.jianshu.com/p/2ea0406d0793" target="_blank" rel="noopener noreferrer">信息熵、条件熵、联合熵、互信息、相对熵、交叉熵<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>细节一：在使用 Jensen 不等式的时候，需要假设隐变量服从某种形式的概率分布，才可以将推导过程的一部分看成是期望的表达形式从而应用 Jensen 不等式。然而这个分布不是随便指定的。我们令 Jensen 不等式取等号的时候，可以计算出这个分布其实就是：<strong>已知观测数据的隐变量的后验概率分布</strong>。由于求 Q 函数需要先求出隐变量的后验概率的期望，因此，这就可以解释为什么EM算法的“通俗”理解角度的E步骤是求隐变量的期望了。</p> <p>细节二：Q 函数与<strong>完全数据的对数似然函数</strong>的关系。有时候在用 EM 算法解决某个具体问题的时候，会发现 M 步骤极大化的居然是<strong>完全数据的对数似然函数</strong>。这是因为，Q 函数虽然是完全数据的对数似然函数的某种期望，但是<strong>求这个期望的过程有时其实就是将隐变量的后验概率的期望代入就可以了</strong>。因此，<strong>本质上我们其实还是在求 Q 函数的极大</strong>。</p> <h3 id="高斯混合模型"><a href="#高斯混合模型" class="header-anchor">#</a> 高斯混合模型</h3> <p>模型假设：多个高斯分布的加权平均（线性组合），权重（系数）之和为 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mn class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn></mjx-math></mjx-container>。</p> <p>隐变量 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="z"></mjx-c></mjx-mi></mjx-math></mjx-container> ：样本 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="x"></mjx-c></mjx-mi></mjx-math></mjx-container> 属于哪一个高斯分布，<mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="x"></mjx-c></mjx-mi></mjx-math></mjx-container> 与 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="z"></mjx-c></mjx-mi></mjx-math></mjx-container> 一一对应，因为 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="z"></mjx-c></mjx-mi></mjx-math></mjx-container> 是离散型随机变量，因此可以有一个概率分布（可以认为属于两个分布，概率有大有小）。</p> <p>生成模型：生成过程如下：1、随机选择一个高斯分布；2、从这个高斯分布生成一个数据。</p> <p>直接使用极大似然估计，不能得到解析解。</p> <p>下面是高斯混合模型的例子：</p> <p>输入：观测数据和类别的总数。</p> <p>输出：观测数据所服从的几个分布函数的参数。</p> <blockquote><p>例如：输入：7000 份成绩，来自 4 个科目：语文、数学、英语、计算机。
输出：4 个科目分别服从的分布的参数值，由于各科成绩服从高斯分布，因此输出为每科成绩的分布参数 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="Y"></mjx-c></mjx-mi><mjx-mo space="4" class="mjx-n"><mjx-c c="="></mjx-c></mjx-mo><mjx-mo space="4" class="mjx-n"><mjx-c c="{"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-msub><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3BC"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3C3"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-mo space="2" class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-msub><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3BC"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="2"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3C3"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="2"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-mo space="2" class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-msub><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3BC"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="3"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3C3"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="3"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c c="("></mjx-c></mjx-mo><mjx-msub><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3BC"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="4"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3C3"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="4"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=")"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c c="}"></mjx-c></mjx-mo></mjx-math></mjx-container>，以及样本服从各个分布的概率 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mi class="mjx-i"><mjx-c c="3D5"></mjx-c></mjx-mi><mjx-mo space="4" class="mjx-n"><mjx-c c="="></mjx-c></mjx-mo><mjx-mo space="4" class="mjx-n"><mjx-c c="{"></mjx-c></mjx-mo><mjx-msub><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3D5"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="1"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3D5"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="2"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3D5"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="3"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c=","></mjx-c></mjx-mo><mjx-msub space="2"><mjx-mi noIC="true" class="mjx-i"><mjx-c c="3D5"></mjx-c></mjx-mi><mjx-script style="vertical-align:-0.15em;"><mjx-mn size="s" class="mjx-n"><mjx-c c="4"></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class="mjx-n"><mjx-c c="}"></mjx-c></mjx-mo></mjx-math></mjx-container>。</p></blockquote> <p>EM 算法解决这个的思路是使用启发式的迭代方法，既然我们无法直接求出模型分布参数，那么我们可以先猜想隐含参数（EM 算法的 E 步），接着基于观察数据和猜测的隐含参数一起来极大化对数似然，求解我们的模型参数（EM算法的M步)。由于我们之前的隐含参数是猜测的，所以此时得到的模型参数一般还不是我们想要的结果。我们基于当前得到的模型参数，继续猜测隐含参数（EM算法的 E 步），然后继续极大化对数似然，求解我们的模型参数（EM算法的M步)。以此类推，不断的迭代下去，直到模型分布参数基本无变化，算法收敛，找到合适的模型参数。</p> <p>这个时候有人就想到我们必须从某一点开始，并用迭代的办法去解决这个问题：我们先设定男生身高和女生身高分布的几个参数（初始值），然后根据这些参数去判断每一个样本（人）是男生还是女生，之后根据标注后的样本再反过来重新估计参数。之后再多次重复这个过程，直至稳定。这个算法也就是EM算法。</p> <p>又如：得到一堆身高数据，但是不知道这些身高数据是男生还是女生。</p> <p>对于每一个样本或者你抽取到的人，就有两个问题需要估计了，一是这个人是男的还是女的，二是男生和女生对应的身高的正态分布的参数是多少。这两个问题是相互依赖的。</p> <p>有了每个人的归属，或者说我们已经大概地按上面的方法将这 200 个人分为男生和女生两部分，我们就可以根据之前说的最大似然那样，
通过这些被大概分为男生的 n 个人来重新估计第一个分布的参数，女生的那个分布同样方法重新估计。这个是 Maximization。</p> <p>然后，当我们更新了这两个分布的时候，每一个属于这两个分布的概率又变了，那么我们就再需要调整 E 步。如此往复，直到参数基本不再发生变化为止。</p> <p>具体方法为：隐变量是一个数据是男生身高数据还是女生身高数据。</p> <p>E 步：先设定男生和女生的身高分布参数（初始值，即模型参数），例如男生的身高分布为 ， 女生的身高分布为  ，当然了，刚开始肯定没那么准；
然后计算出每个人更可能属于第一个还是第二个正态分布中的（例如，这个人的身高是 <mjx-container jax="CHTML" class="MathJax"><mjx-math class=" MJX-TEX"><mjx-mn class="mjx-n"><mjx-c c="1"></mjx-c><mjx-c c="8"></mjx-c><mjx-c c="0"></mjx-c></mjx-mn></mjx-math></mjx-container>cm，那很明显，他极大可能属于男生），这个是属于 Expectation 一步；</p> <p>M 步：求问题参数，我们已经大概地按上面的方法将这 200 个人分为男生和女生两部分，我们就可以根据之前说的极大似然估计分别对男生和女生的身高分布参数进行估计（这不变成了极大似然估计了吗？极大即为Maximization）这步称为 Maximization。</p> <p>然后，当我们更新这两个分布的时候，每一个学生属于女生还是男生的概率又变了，那么我们就再需要调整 E 步；
如此往复，直到参数基本不再发生变化或满足结束条件为止。</p> <p>上面的学生属于男生还是女生我们称之为隐含参数，女生和男生的身高分布参数称为模型参数。</p> <p>EM 算法解决这个的思路是使用启发式的迭代方法，既然我们无法直接求出模型分布参数，那么我们可以先猜想隐含参数（EM 算法的 E 步），接着基于观察数据和猜测的隐含参数一起来极大化对数似然，求解我们的模型参数（EM 算法的 M 步)。由于我们之前的隐含参数是猜测的，所以此时得到的模型参数一般还不是我们想要的结果。我们基于当前得到的模型参数，继续猜测隐含参数（EM 算法的 E 步），然后继续极大化对数似然，求解我们的模型参数（EM 算法的 M 步)。以此类推，不断的迭代下去，直到模型分布参数基本无变化，算法收敛，找到合适的模型参数。</p> <p>这个时候有人就想到我们必须从某一点开始，并用迭代的办法去解决这个问题：我们先设定男生身高和女生身高分布的几个参数（初始值），然后根据这些参数去判断每一个样本（人）是男生还是女生，之后根据标注后的样本再反过来重新估计参数。之后再多次重复这个过程，直至稳定。这个算法也就是EM算法。</p> <p>引入了坐标上升法。</p> <p>应用： EM 算法有很多的应用，最广泛的就是 GMM 混合高斯模型、聚类、HMM 等等。
具体可以参考 JerryLead 的 cnblog 中 的Machine Learning 专栏。</p> <p>应用：隐马尔科夫模型， LDA 主题模型。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <p>[1] 李航. 统计学习方法（第 2 版）第 9 章“EM 算法及其推广”. 北京：清华大学出版社，2019.</p> <p>说明：公式很多，写得比较晦涩，但是比较全面，理解书上的内容和细节要查阅一些资料。</p> <p>[2] 周志华. 机器学习（第 7 章第 6 节“EM 算法”）. 北京：清华大学出版社，2017.</p> <p>（本节完）</p> <hr> <p>以下为草稿，我自己留着备用，读者可以忽略，欢迎大家批评指正。</p> <h3 id="参考资料-2"><a href="#参考资料-2" class="header-anchor">#</a> 参考资料</h3> <p>1、知乎：EM算法存在的意义是什么？</p> <p>https://www.zhihu.com/question/40797593/answer/275171156</p> <p>2、Orange先生：浅谈 EM 算法的两个理解角度
https://blog.csdn.net/xmu_jupiter/article/details/50936177</p> <p>说明：这篇文章没有抄公式，把重要的思想部分提取出来。</p> <p>3、人人都懂EM算法：https://zhuanlan.zhihu.com/p/36331115
说明：看这篇文章终于知道了个大概。</p> <p>4、刘建平的文章：https://www.cnblogs.com/pinard/p/6912636.html</p> <p>说明：如果手边没有《统计学习方法》这本书，可以看这篇博客。</p> <p>5、Lasso回归算法： 坐标轴下降法与最小角回归法小结：
http://www.cnblogs.com/pinard/p/6018889.html</p> <p>6、混合高斯模型（Mixtures of Gaussians）和EM算法
https://www.cnblogs.com/jerrylead/archive/2011/04/06/2006924.html</p> <p>7、数据分析师进阶必备6大数学利器
https://mp.weixin.qq.com/s/BH4hsLjv7rLvR8xOLU1iNQ</p> <p>8、矩阵论：向量范数和矩阵范数
https://blog.csdn.net/pipisorry/article/details/51030563</p> <p>9、知乎上的问题：怎么通俗易懂地解释EM算法并且举个例子?
https://www.zhihu.com/question/27976634/answer/163164402</p> <p>10、从最大似然到EM算法浅解
https://blog.csdn.net/zouxy09/article/details/8537620</p> <p>11、<a href="https://zhuanlan.zhihu.com/p/54831287" target="_blank" rel="noopener noreferrer">深入浅出之EM算法(一）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>12、<a href="https://zhuanlan.zhihu.com/p/54890367" target="_blank" rel="noopener noreferrer">深入浅出EM算法（2）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>13、极客时间：</p> <p><a href="https://time.geekbang.org/column/article/81896" target="_blank" rel="noopener noreferrer">28丨EM聚类（上）：如何将一份菜等分给两个人？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://time.geekbang.org/column/article/82333" target="_blank" rel="noopener noreferrer">29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>14、<a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener noreferrer">从最大似然到EM算法浅解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>15、K-Means聚类算法原理
http://www.cnblogs.com/pinard/p/6164214.html</p> <p>16、用scikit-learn学习K-Means聚类
https://www.cnblogs.com/pinard/p/6169370.html</p> <p>17、http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html</p> <p>18、“上帝的算法”——EM
https://blog.csdn.net/sb19931201/article/details/53586468?utm_source=blogxgwz1
这篇文章主要是摘抄。写了很多参考文献。</p> <p>说明：这篇文章 EM 算法的推导直接从极大似然估计开始，讲到了我们的目标就是求观测数据的极大似然。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">4/10/2021, 6:19:58 PM</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/book/assets/js/app.a4355b0d.js" defer></script><script src="/book/assets/js/2.ba785ee6.js" defer></script><script src="/book/assets/js/41.f7b72b7a.js" defer></script>
  </body>
</html>
